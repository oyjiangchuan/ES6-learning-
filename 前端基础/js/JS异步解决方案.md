#### 产生异步的原因

- js是单线程语言 遇到耗时长的任务 如果没有异步模式 会导致页面阻塞卡死 其他任务无法执行 所以js将任务执行的模式分为：同步和异步
- 同步模式：就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的
- 异步模式：每一个任务有一个或多个回调函数(callback)，前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的，在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，异步模式甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降

#### 异步解决方案

- 回调函数(callback)
- 事件监听(发布/订阅)解析
- Promise解析及从0～1的源码体验
- Generator全面解析
- Async/Await解析


#### 回调函数

`一个函数`被`作为参数`传递给另一个函数，即`一个被作为参数传递的函数`
回调并不一定就是异步，并没有直接关系，不过回调函数是异步的一种解决方案
异步编程的最基本方式

- 假设有两个函数f1和f2，后者等待前者的执行结果
```js
f1()
f2()
```

- 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数
```js
function f1(callback) {
  setTimeout(() => {
    callback && callback()
  }, 1000)
}
f1(f2)
```

- 采用这种方式，我们把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行

- 回调函数
  - 优点：简单、容易理解和部署，
  - 缺点：
    - 不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程混乱，而且每个任务只能指定一个回调函数，层层嵌套造成回调地狱
    - 异步回调中，回调函数的执行栈与原函数分离开，外部无法抓住异常，异常会变得不可控


#### 事件监听(发布/订阅)


#### Promise

#### Generator

#### async/await


#### 参考

[「硬核 JS」深入了解异步解决方案](https://juejin.cn/post/6844904050543034376#heading-31)