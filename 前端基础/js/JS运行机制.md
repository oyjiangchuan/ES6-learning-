### JS 运行机制

#### 进程和线程

- 进程：
  - 进行中的程序，进程是 CPU 资源分配的最小单位；
  - 进程包括运行中的程序和程序所使用到的内存和系统资源；
  - 每个进程之间是相互独立的；
  - CPU 可以有很多进程；CPU 在运行一个进程时，其他的进程处于非运行状态
  - CPU 使用 `时间片轮转调度算法` 来实现同时运行多个进程
- 线程：
  - 线程是 CPU 调度的最小单位，是建立在进程的基础上的一次程序运行单位，通俗点解释线程就是程序中的一个执行流，一个进程可以有多个线程
  - 一个进程中只有一个执行流称作单线程，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行
  - 一个进程中有多个执行流称作多线程，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务

#### JS 为什么是单线程

- js 是运行于浏览器上的脚本语言，主要用途是和用户交互以及操作 DOM，所以只能是单线程；假设 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
- Web Worker 可以开启多线程，但是子线程是完全受主线程控制的，且不得操作 DOM

#### 浏览器的主要进程

> 浏览器是多进程的 且每个进程又有很多线程

- Browser 进程

  - 浏览器的主进程(负责协调、主控)，该进程只有一个
  - 负责浏览器界面显示，与用户交互。如前进，后退等
  - 负责各个页面的管理，创建和销毁其他进程
  - 将渲染(Renderer)进程得到的内存中的 Bitmap(位图)，绘制到用户界面上
  - 网络资源的管理，下载等

- 第三方插件进程

  - 每种类型的插件对应一个进程，当使用该插件时才创建

- GPU 进程

  - 该进程也只有一个，用于 3D 绘制等等

- 渲染进程(重)
  - 即通常所说的浏览器内核(Renderer 进程，内部是多线程)
  - 每个 Tab 页面都有一个渲染进程，互不影响
  - 主要作用为页面渲染，脚本执行，事件处理等

#### 渲染进程(Renderer)的主要线程

> 渲染进程是多线程的；页面的渲染、JS 的执行、事件的循环，都在渲染进程内执行

- GUI 渲染线程(页面渲染线程)

  - 负责渲染浏览器界面，解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
    - 解析 html 代码(HTML 代码本质是字符串)转化为浏览器认识的节点，生成 DOM 树，也就是 DOM Tree
    - 解析 css，生成 CSSOM(CSS 规则树)
    - 把 DOM Tree 和 CSSOM 结合，生成 Rendering Tree(渲染树)
  - 当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)
  - 当我们修改元素的尺寸，页面就会回流(Reflow)
  - 当页面需要 Repaing 和 Reflow 时 GUI 线程执行，绘制页面
  - 回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免 Reflow 和 Repaint
  - GUI 渲染线程与 JS 引擎线程是互斥的
    - 当 JS 引擎执行时 GUI 线程会被挂起(相当于被冻结了)
    - GUI 更新会被保存在一个队列中等到 JS 引擎空闲时立即被执行

- JS 引擎线程(js 的解析和执行线程)

  - JS 引擎线程就是 JS 内核，负责处理 Javascript 脚本程序(例如 V8 引擎)
  - JS 引擎线程负责解析 Javascript 脚本，运行代码
  - JS 引擎一直等待着任务队列中任务的到来，然后加以处理
    - 浏览器同时只能有一个 JS 引擎线程在运行 JS 程序，所以 js 是单线程运行的
    - 一个 Tab 页(renderer 进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序
  - GUI 渲染线程与 JS 引擎线程是互斥的，js 引擎线程会阻塞 GUI 渲染线程
    - 就是我们常遇到的 JS 执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)
    - 例如浏览器渲染的时候遇到`<script>`标签，就会停止 GUI 的渲染，然后 js 引擎线程开始工作，执行里面的 js 代码，等 js 执行完毕，js 引擎线程停止工作，GUI 继续渲染下面的内容。所以如果 js 执行时间太长就会造成页面卡顿的情况

- 事件触发线程(管理事件绑定和异步操作的回调线程，管理任务事件队列，其内放置着各种绑定事件和异步操作的回调事件)

  > `事件触发线程`管理着来自类似定`时触发器线程`和`异步http请求线程`的回调任务事件队列

  - 属于浏览器而不是 JS 引擎，用来控制事件循环，并且管理着一个事件队列(task queue)
  - 当 js 执行碰到事件绑定和一些异步操作(如 setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX 异步请求等)，会走`事件触发线程`将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待 js 引擎线程空闲时来处理。
  - 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理
  - 因为 JS 是单线程，所以这些待处理队列中的事件都得排队等待 JS 引擎处理

- 定时触发器线程

  - setInterval 与 setTimeout 所在线程
  - 浏览器定时计数器并不是由 JavaScript 引擎计数的(因为 JavaScript 引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)
  - 通过单独线程来计时并触发定时(计时完毕后，添加到`事件触发线程`的事件队列中，等待 JS 引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程
  - W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms

- 异步 http 请求线程
  - 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
  - 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行
  - 简单说就是当执行到一个 http 异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是 http 状态变化)，再把回调函数添加到事件队列，等待 js 引擎线程来执行

#### 同步+异步的 Event Loop

JS 分为`同步任务`和`异步任务`，`同步任务`都在主线程(这里的主线程就是 JS 引擎线程)上执行，会形成一个`执行栈`

主线程之外，事件触发线程管理着一个`任务队列`，只要异步任务有了运行结果，就在任务队列之中放一个事件回调

一旦`执行栈`中的所有`同步任务`执行完毕(也就是 JS 引擎线程空闲了)，系统就会读取`任务队列`，将可运行的异步任务(`任务队列`中的事件回调，只要任务队列中有事件回调，就说明可以执行)添加到执行栈中，开始执行

主线程执行栈中执行完毕，JS 引擎线程空闲，就会向事件触发线程发起询问，询问事件触发线程的事件队列中是否有需要执行的回调函数，如果有将事件队列中的回调事件`加入执行栈中`，开始执行回调；如果事件队列中没有回调，JS 引擎线程`会一直发起询问`，直到有为止

浏览器上的所有线程的工作都很单一且独立，非常符合单一原则

`定时触发线程`只管理定时器且只关注定时不关心结果，定时结束就把回调扔给`事件触发线程`

`异步http请求线程`只管理 http 请求同样不关心结果，请求结束把回调扔给`事件触发线程`

`事件触发线程`只关心异步回调入事件队列

而我们`JS引擎线程`只会执行执行栈中的事件，执行栈中的代码执行完毕，就会读取事件队列中的事件并添加到执行栈中继续执行，这样反反复复就是我们所谓的`事件循环(Event Loop)`

- 图解
  ![图解](./images/eventLoop1.awebp)

- 梳理过程：
  - 执行栈开始顺序执行
  - 判断是否为同步，异步则进入异步线程，最终事件回调给事件触发线程的任务队列等待执行，同步继续执行
  - 执行栈空，询问任务队列中是否有事件回调
  - 任务队列中有事件回调则把回调加入`执行栈末尾`继续从第一步开始执行
  - 任务队列中没有事件回调则`不停发起询问`

#### 宏任务(macrotask)和微任务(microtask)

- 宏任务：

  - 我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)，每一个宏任务会从头到尾执行完毕，不会执行其他
  - 由于`JS引擎线程`和`GUI渲染线程`是`互斥`的关系，浏览器为了能够使`宏任务`和`DOM任务`有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，GUI 渲染线程开始工作，对页面进行渲染

  ```
    宏任务 => GUI渲染 => 宏任务 ...
  ```

  - 常见的宏任务
    - 主代码块
    - setTimeout
    - setInterval
    - setImmediate() => Node
    - requestAnimationFrame() => 浏览器

- 微任务

  - ES6 新引入了 Promise 标准，同时浏览器实现上多了一个 microtask 微任务概念，在 ECMAScript 中，microtask 也被称为 jobs
  - 我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务
  - 当一个宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完

  ```
    宏任务 => 微任务 => GUI渲染 => 宏任务 ...
  ```

  - 常见的微任务
    - process.nextTick() => Node
    - Promise.then()
    - catch
    - finally
    - await
    - Object.observe
    - MutationObserver => [监听 DOM 树的变化](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)

- 微任务宏任务注意点
  - 浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务
  - 微任务和宏任务`不在一个任务队列`，`不在一个任务队列`
    - 例如`setTimeout`是一个宏任务，它的`事件回调在宏任务队列`，`Promise.then()`是一个微任务，它的`事件回调在微任务队列`，二者并不是一个任务队列
    - 以 Chrome 为例，有关渲染的都是在渲染进程中执行，渲染进程中的任务（DOM 树构建，js 解析…等等）需要主线程执行的任务都会在主线程中执行，而浏览器维护了一套事件循环机制，主线程上的任务都会放到消息队列中执行，主线程会循环消息队列，并从头部取出任务进行执行，如果执行过程中产生其他任务需要主线程执行的，渲染进程中的其他线程会把该任务塞入到消息队列的尾部，消息队列中的任务都是宏任务
    - 微任务是如何产生的呢？当执行到 script 脚本的时候，js 引擎会为全局创建一个执行上下文，在该执行上下文中维护了一个微任务队列，当遇到微任务，就会把微任务回调放在微队列中，当所有的 js 代码执行完毕，在退出全局上下文之前引擎会去检查该队列，有回调就执行，没有就退出执行上下文，这也就是为什么微任务要早于宏任务，也是大家常说的，每个宏任务都有一个微任务队列（由于定时器是浏览器的 API，所以定时器是宏任务，在 js 中遇到定时器会也是放入到浏览器的队列中）

#### 同步+异步(宏任务+微任务)完整的 Event Loop

- 图解
  ![图解](./images/eventLoop2.awebp)

- 梳理过程

  - 首先，整体的 script(作为第一个宏任务)开始执行的时候，会把所有代码分为同步任务、异步任务两部分
  - 同步任务会直接进入主线程依次执行
  - 异步任务会再分为宏任务和微任务
  - 宏任务进入到 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中
  - 微任务也会进入到另一个 Event Table 中，并在里面注册回调函数，每当指定的事件完成时，Event Table 会将这个函数移到 Event Queue 中
  - 当主线程内的任务执行完毕，主线程为空时，会检查微任务的 Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务
  - 上述过程会不断重复，这就是 Event Loop，比较完整的事件循环

- 先执行同步代码(执行完成之后) => 检查任务队列，先微后宏，有事件回调，入主线程执行

> 宏任务和微任务和同步异步无关，只是在异步任务中会区分`宏任务`和`微任务`，对于维护宏任务和微任务的队列
> 整体的 script 开始执行的时作为第一个宏任务

#### 关于 Promise 和 async/await 函数

`new Promise()`是一个构造函数，这是一个同步任务
后面的`.then()`才一个异步微任务

`async/await`本质上还是基于`Promise`的一些封装，而`Promise`是属于微任务的一种
在使用`await`关键字与`Promise.then`效果类似

可以理解为，`await`之前的代码，相当于与`new Promise`的同步代码，`await`以后的代码相当于 `Promise.then`的异步

- `await`后面不是`Promise`对象时，直接执行
- `await`后面是`Promise`对象 会阻塞后面的代码，`Promise`对象`resolve`，然后得到`resolve`的值，作为`await`表达式的运算结果
  > `async` 函数返回的是一个 `Promise` 对象，如果在 `async` 函数中直接 `return` 一个直接量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成`Promise`对象返回


#### 练习题

```js
async function async1() {
  console.log("async1 start")
  await async2() // async2无返回值 直接执行 相当于同步代码
  console.log("async1 end") // await以后的代码相当于 Promise.then的异步微任务
}
async function async2() {
  console.log("async2")
}
console.log("script start")
setTimeout(function () {
  console.log("setTimeout")
}, 0)
async1()
new Promise(function (resolve) {
  console.log("promise1")
  resolve()
}).then(function () {
  console.log("promise2")
})
console.log("script end")
// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// promise2
// setTimeout

```

#### NodeJS 中的运行机制
......待补充

#### 参考

[「硬核 JS」一次搞懂 JS 运行机制](https://juejin.cn/post/6844904050543034376#heading-31)
